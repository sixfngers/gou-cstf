package com.citw.fx {	import com.greensock.*;	import com.greensock.easing.*;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.display.MovieClip;	import flash.events.Event;	import flash.geom.Point;	import flash.filters.DisplacementMapFilter;	import flash.filters.DisplacementMapFilterMode;	import flash.display.BitmapDataChannel;	import com.helper.EventWithVariables;	import com.citw.fx.Displace;	import flash.geom.Rectangle;	import flash.geom.Matrix;	public class TVGlitch extends MovieClip {		var obj;				public static function QuickGlitch(target, delay=0, o=null) {			var obj = o==null?{}:o;			if(delay != 0) {				target.visible = false;				TweenMax.delayedCall(delay, function() {TVGlitch.QuickGlitch(target, 0, o);}, null, obj.hasOwnProperty("useFrames")?obj.useFrames:false);				return;			}			target.visible = true;			var rect = new Rectangle(target.x, target.y, target.width, target.height);			new TVGlitch(target, rect, Displace.getMap(rect), {delay:obj.hasOwnProperty("delay")?obj.delay:4, useFrames:obj.hasOwnProperty("useFrames")?obj.useFrames:true, maskOut:true});		}		public function TVGlitch(t, rect, displace, o) {			// constructor code			obj = o;						//delay=0.25, useFrames=false, maskO=false, customDistAmp=null, updateEveryF=false						if(!obj.hasOwnProperty("delay")) {				obj.delay = 0.25;			}						if(!obj.hasOwnProperty("useFrames")) {				obj.useFrames = false;			}						if(!obj.hasOwnProperty("maskOut")) {				obj.maskOut = false;			}						if(!obj.hasOwnProperty("customDistAmp")) {				obj.customDistAmp = null;			}						if(!obj.hasOwnProperty("updateEveryFrame")) {				obj.updateEveryFrame = false;			}						if(!obj.hasOwnProperty("adjustQuality")) {				obj.adjustQuality = true;			}									target = t;			target.alpha = 0;						maskOut = obj.maskOut;			updateEveryFrame = obj.updateEveryFrame;						snapshotBMD = new BitmapData(rect.width, rect.height, true, 0);			snapshot = new Bitmap(snapshotBMD);			var matrix = new Matrix();			if(obj.hasOwnProperty("customRect")) {				matrix.translate(-obj.customRect.x, -obj.customRect.y);			}			snapshotBMD.draw(target, matrix, null, null, obj.hasOwnProperty("customRect")?null:null);						noiseBMD = new BitmapData(rect.width,rect.height,true,0);			noise = new Bitmap(noiseBMD);			TweenMax.to(noise, 0, {colorMatrixFilter:{saturation:0.25}});			container = new MovieClip();						if(obj.customDistAmp == null) {				distAmp = (snapshot.width*0.5);			}else {				distAmp = obj.customDistAmp;			}						MovieClip(target.parent).addChild(container);						if(obj.adjustQuality) {				target.stage.quality = "LOW";			}						container.x = rect.x;			container.y = rect.y;						if(obj.hasOwnProperty("customRect")) {				container.x = obj.customRect.x;				container.y = obj.customRect.y;				//snapshot.x = -obj.customRect.x;				//snapshot.y = obj.customRect.y;								//noise.y -= obj.customRect.y;			}						container.mouseChildren = container.mouseEnabled = false;						container.addChild(snapshot);			container.addChild(noise);			noise.blendMode = "overlay";						dm = createDMFilter(displace);						addEventListener(Event.ENTER_FRAME, renderGlitch);			TweenMax.delayedCall(obj.delay, killGlitch, null, obj.useFrames);		}				var target;		var snapshotBMD;		var snapshot;		var noiseBMD;		var noise;		var container;		var dm;		var distAmp;		var maskOut;		var updateEveryFrame;		var targetParent;		function killGlitch() {						removeEventListener(Event.ENTER_FRAME, renderGlitch);						if(obj.hasOwnProperty("callback")) {				obj.callback.dispatchEvent(new EventWithVariables("AnimationComplete", true, false, [target]));			}						snapshotBMD.dispose();			noiseBMD.dispose();						target.alpha = 1;									if(target.hasOwnProperty("stage") && obj.adjustQuality) {				target.stage.quality = "HIGH";			}							MovieClip(container.parent).removeChild(container);		}		function renderGlitch(e=null)		{			if(updateEveryFrame) {				snapshotBMD.floodFill(0, 0, 0);				snapshotBMD.draw(target);			}						noiseBMD.noise(Math.random()*100);			dm.scaleX = Math.random()*distAmp-distAmp*0.5;			snapshot.filters = new Array(dm);			TweenMax.to(snapshot, 0, {colorMatrixFilter:{brightness:Math.random()*1.75+0.25, contrast:Math.random()*1.75+0.25}});						if(Math.floor(Math.random()*20) == 0) {				var offsetR = Math.random();				var offsetG = Math.random();				var offsetB = Math.random();				TweenMax.to(snapshot, 0, {colorTransform:{redMultiplier:offsetR, redOffset:offsetR*255, greenMultiplier:offsetG, greenOffset:offsetG*255, blueMultiplier:offsetB, blueOffset:offsetB*255}});			}						if(!maskOut) return;			var temp = new BitmapData(snapshot.width, snapshot.height, true, 0);			temp.draw(snapshot);			noiseBMD.copyChannel(temp, snapshotBMD.rect, new Point(0, 0), BitmapDataChannel.ALPHA, BitmapDataChannel.ALPHA);		}		function createDMFilter(from)		{			var sourceBMD = new BitmapData(snapshot.width, snapshot.height, false);			sourceBMD.draw(from);						var mapBitmap:BitmapData = sourceBMD;// use the bitmap data from our StaticMap image			var mapPoint:Point = new Point(0,0);// this is the position of the StaticMap image in relation to our button			var channels:uint = BitmapDataChannel.RED;// which color to use for displacement			var componentX:uint = channels;			var componentY:uint = channels;			var scaleX:Number = 200;// the amount of horizontal shift			var scaleY:Number = 0;// the amount of vertical shift			var mode:String = DisplacementMapFilterMode.WRAP;			var color:uint = 0;			var alpha:Number = 0;					return new DisplacementMapFilter(										mapBitmap,										mapPoint,										componentX,										componentY,										scaleX,										scaleY,										mode,										color,										alpha   );				}	}}