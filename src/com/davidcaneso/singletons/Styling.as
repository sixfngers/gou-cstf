package com.davidcaneso.singletons {	import com.davidcaneso.collections.List;	import com.davidcaneso.text.EmbededFonts;	import com.davidcaneso.utils.StringUtils;	import flash.errors.IllegalOperationError;	import flash.text.StyleSheet;	import flash.text.TextFormat;	public class Styling	{		private static var _instance:Styling;		private var _useDeviceFonts:Boolean;		private var _formats:List;		private var _palette:List;		private var _cssStyleSheet:StyleSheet;		private var _typeSwf:EmbededFonts;		public static function get instance():Styling		{			if (! Styling._instance)			{				Styling._instance = new Styling(new PrivateClass  );			}			return Styling._instance;		}		public function Styling(pvt:PrivateClass):void		{			if (! pvt)			{				throw new IllegalOperationError("You may not instantiate this Singleton class directly. Use the static getter Styling.instance.");			}			else			{				_useDeviceFonts = false;				_palette = new List();				_formats = new List();				_cssStyleSheet = new StyleSheet  ;			}		}		public function addTypeSwf(swf:EmbededFonts):void		{			_typeSwf = swf;		}		public function set useDeviceFonts(val:Boolean):void		{			_useDeviceFonts = val;		}		public function get useDeviceFonts():Boolean		{			return _useDeviceFonts;		}		public function addFormatFromXMLList(xmlList:XMLList):void		{			for each (var fmt:XML in xmlList)			{				addFormatFromXml(fmt);			}		}		public function addFormatFromXml(node:XML):void		{			var attributeNames:XMLList = node. @ *;			var limit:int = attributeNames.length();			var currentAttribute:String;			var fmt:TextFormat = new TextFormat  ;			for (var i:int = 0; i < limit; i++)			{				currentAttribute = attributeNames[i].name().toString();				switch (currentAttribute)				{					case "align" :						fmt[currentAttribute] = attributeNames[i];						break;					case "blockindent" :						fmt.blockIndent = attributeNames[i];						break;					case "bold" :						fmt.bold = false;						if (attributeNames[i] == 'true')						{							fmt.bold = true;							//fmt[currentAttribute] = attributeNames[i]						}						break;					case "bullet" :						fmt[currentAttribute] = attributeNames[i];						break;					case "color" :						if (isNaN(Number(attributeNames[i])))						{							//trace("set color using palette "+get_colorPalette().findByName( String(attributeNames[i]) ))							fmt[currentAttribute] = findColor(String(attributeNames[i]));						}						else						{							//trace("set color using number "+Number( String(attributeNames[i]) ))							fmt[currentAttribute] = Number(attributeNames[i]);						}						break;					case "font" :						if ((_typeSwf != null))						{							fmt[currentAttribute] = EmbededFonts(_typeSwf).getFont(StringUtils.removeSpaces(attributeNames[i]));						}						break;					case "indent" :						fmt[currentAttribute] = attributeNames[i];						break;					case "italic" :						fmt.italic = false;						if (attributeNames[i] == 'true')						{							fmt.italic = true;							//fmt[currentAttribute] = attributeNames[i]						}						break;					case "kerning" :						fmt[currentAttribute] = attributeNames[i];						break;					case "leading" :						fmt[currentAttribute] = attributeNames[i];						break;					case "letterspacing" :						fmt.letterSpacing = attributeNames[i];						break;					case "leftmargin" :						fmt.leftMargin = attributeNames[i];						break;					case "rightmargin" :						fmt.rightMargin = attributeNames[i];						break;					case "size" :						fmt[currentAttribute] = attributeNames[i];						break;					case "tabstops" :						fmt.tabStops = attributeNames[i].split(",") as Array;						break;					case "target" :						fmt[currentAttribute] = attributeNames[i];						break;					case "underline" :						fmt[currentAttribute] = attributeNames[i];						break;					case "url" :						fmt[currentAttribute] = attributeNames[i];						break;				}			}			addFormat(node. @ name,fmt);		}		public function addFormat(formatName:String,format:TextFormat):void		{			_formats.addToList(formatName,format);		}		public function findFormat(formatName:String):TextFormat		{			var format:TextFormat = TextFormat(_formats.findInList(formatName));			if ((format == null))			{				format = new TextFormat  ;			}			return format;		}		public function addColorFromXmlList(xml:XMLList,namesAttribute:String='name',valuesAttribute:String='value'):void		{			var limit:int = xml.children().length();			for (var i:int = 0; i < limit; i++)			{				addColor(xml.children()[i].@[namesAttribute],Number(xml.children()[i].@[valuesAttribute]));			}		}		public function addColor(colorName:String,colorValue:Number):void		{			_palette.addToList(colorName,Number(colorValue));		}		public function findColor(colorName:String):Number		{			return Number(_palette.findInList(colorName));		}		public function addStyleSheet(cssText:String):void		{			_cssStyleSheet.parseCSS(cssText);		}		public function get cssStyleSheet():StyleSheet		{			return _cssStyleSheet;		}		public function showColors():void		{			trace(_palette.displayListString());		}		public function showFormats():void		{			trace(_formats.displayListString());		}	}}//Singleton Enforcerclass PrivateClass { }