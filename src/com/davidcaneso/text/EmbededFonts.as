package com.davidcaneso.text{	import flash.display.MovieClip;	import flash.events.Event;	import flash.system.ApplicationDomain;	import flash.text.Font;	import com.davidcaneso.events.framework.TypefaceSetupEvent;	public class EmbededFonts extends MovieClip	{		protected var fontsToRegister:Array;		private var _fonts:Object = new Object();		public function EmbededFonts():void		{			fontsToRegister = [];			addEventListener(Event.ADDED_TO_STAGE,_init);		}		//public methods		public function getFont(className:String):String		{			return _fonts[className];		}		//private methods		protected function _init(e:Event):Array		{			removeEventListener(Event.ADDED_TO_STAGE,_init);			var fonts:Array = [];			if (fontsToRegister.length > 0)			{				fonts = _registerFonts(this.loaderInfo.applicationDomain,fontsToRegister);			}			stage.dispatchEvent(new TypefaceSetupEvent(TypefaceSetupEvent.SETUP,this));			return fonts;		}		private function _registerFonts(fontDomain:ApplicationDomain,classNames:Array):Array		{			var valid:Array = [];			var invalid:Array = [];			var returnArray:Array = [valid,invalid];			var i:int = classNames.length;			while (i--)			{				var validFont:Boolean = false;				var className:String = String(classNames[i]);				if (fontDomain.hasDefinition(className))				{					var fontClass:Class = fontDomain.getDefinition(className) as Class;					if (fontClass)					{						Font.registerFont(fontClass);						var font:Font = new fontClass   as Font;						if (font)						{							//font has been validated good to use							_fonts[className] = font.fontName;							valid.push(className);							validFont = true;						}					}				}				if (! validFont)				{					invalid.push(className);				}			}			return returnArray;		}	}}