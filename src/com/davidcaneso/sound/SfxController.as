/*creates a interface for playing sound effectsauthor:David Canesocontact:code@davidcaneso.comversion:1.1date:10/03/09change log:v_1.0 - first buildv_1.1 - added muting and unmuting capabilites.added in a _killTraces property false by default.setting _killTraces = true will not write any traces to the output window in the ide._killTraces can only be set in the constructor.makes debugging within a project easier.TODO:add ability to play streaming sound effectsThe MIT LicenseCopyright (c) 2009 David CanesoPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.*/package com.davidcaneso.sound {	import com.davidcaneso.collections.List;	import flash.media.Sound;	public class SfxController	{		//properties		private var _killTraces:Boolean;		private var _isMuted:Boolean;		private var _list:List;		private var _loopingList:List;		private var volume:Number;		//constants		// constructor		public function SfxController(killTraces:Boolean=false):void		{			_killTraces = killTraces;			classTracer("creating SfxController");			_list = new List  ;			_loopingList = new List  ;			set_isMuted(false);			volume = 1;		}		//methods		public function addLibraryEffect(name:String,sound:Sound):void		{			_list.addToList(name,new Effect(sound));		}		public function removeEffect(name:String):void		{			_list.removeFromList(name);		}		public function playEffect(name:String,vol:Number=1,pan:Number=0,loop:Number=0):void		{			trace(((('play sound ' + name) + ' at vol ') + vol));			if (get_isMuted())			{				classTracer('SfxController is muted no sound will be played');				return;			}			var s:Effect = Effect(_list.findInList(name));			if ((loop < 0))			{				_loopingList.addToList(name,s);			}			if ((s != null))			{				s.playEffect(vol,pan,loop);			}			else			{				classTracer('sound name not valid \nname make sure you added that sound to the library');			}		}		public function stopEffect(name:String):void		{			//classTracer('hit stop effect');			var s:Effect = Effect(_loopingList.findInList(name));			_loopingList.removeFromList(name);			if ((s != null))			{				s.stopEffect();			}			else			{				classTracer('sound name not valid \nname make sure you are stopping a sound currently playing');			}		}		public function mute():void		{			if (get_isMuted())			{				classTracer('sound already muted');				return;			}			set_isMuted(true);			var s:Effect;			var soundNames:Array = _loopingList.names;			var limit:int = soundNames.length;			for (var i:int = 0; i < limit; i++)			{				trace(soundNames[i]);				s = Effect(_loopingList.findInList(soundNames[i]));				s.stopEffect();			}		}		public function unmute():void		{			if (! get_isMuted())			{				classTracer('sound already unmuted');				return;			}			set_isMuted(false);			var s:Effect;			var soundNames:Array = _loopingList.names;			var limit:int = soundNames.length;			for (var i:int = 0; i < limit; i++)			{				s = Effect(_loopingList.findInList(soundNames[i]));				s.playEffect(s.get_loopVol(),s.get_loopPan(),-1);			}		}		public function changeVolume(vol:Number):void		{			var s:Effect;			var soundNames:Array = _loopingList.names;			var limit:int = soundNames.length;			for (var i:int = 0; i < limit; i++)			{				s = Effect(_loopingList.findInList(soundNames[i]));				s.changeVolume(vol);			}			volume = vol;		}		//getters and setters		public function get_isMuted():Boolean		{			return _isMuted;		}		private function set_isMuted(val:Boolean=false):void		{			var valid:Boolean;			if(!val)			{				valid = false;			}			else			{				valid = true;			}			_isMuted = valid;		}		public function get_list():List		{			return _list;		}		public function get_volume():Number		{			return volume;		}		private function classTracer(val:String):void		{			if (! _killTraces)			{				trace(val);			}		}	}}