/*	A Queue is much like a line for a carnival ride	you place anonymous objects into the queue	then retrieve them one at a time from the front of the line.		you can get values from the front of the line	nextInQueue()		you can add to the end of the queue	insertInQueue(value)		you can cut to the front of the queue	insertInQueue(value, 0)		you can insert an item anywhere else in the queue	if the place of insertion is greater than the length	the value will get added to the end	insertInQueue(value, 20)		you can empty the queue	clearQueue()		and you can merge two existing queues in multiple ways	put one in front of the other	merge(Queue, Queue.APPEND_FRONT_MERGE_TYPE)		put one in back of the other	merge(Queue, Queue.APPEND_END_MERGE_TYPE)		randomly insert them in places	merge(Queue, Queue.DISTRIBUTE_RANDOM_MERGE_TYPE)		insert item after every other in the current queue	merge(Queue, Queue.DISTRIBUTE_EVEN_MERGE_TYPE)	*/package com.davidcaneso.collections{	//	imports	import com.davidcaneso.utils.MathUtils;		public class Queue	{		//	properties		public static const APPEND_AT			:String = 'appendAt';		public static const APPEND_FRONT		:String = 'appendFront';		public static const APPEND_END			:String = 'appendEnd';		public static const DISTRIBUTE_RANDOM	:String = 'distribute';		public static const DISTRIBUTE_EVEN		:String = 'distributeEven';				private var _items:Array;				//	constructor		public function Queue()		{			_items = new Array();		}				//	methods		public function get queueLength():int		{			return _items.length;		}				public function insertInQueue(item:Object, position:int = -1):void		{						if(position >= 0)			{				if(position >= _items.length) 	_items.push(item);				else							_items.splice(position, 0, item);			}			else			{				_items.push(item);			}		}				public function nextInQueue():Object		{			return _items.shift();		}				public function clearQueue():void		{			var iLimit:int = _items.length;			for(var i:int = 0; i < iLimit; i++)			{				_items.pop();			}		}				public function reverseQueue():void		{			_items.reverse();		}				public function merge(queueToMerge:Queue, mergeType:String = 'appendEnd', earliestPosition:uint = 0):void		{			var i:int;			var iLimit:int = queueToMerge.queueLength;			switch(mergeType)			{				case APPEND_AT:					queueToMerge.reverseQueue();					for(i = 0; i < iLimit; i++)					{						insertInQueue(queueToMerge.nextInQueue(), earliestPosition);					}					break;									case APPEND_FRONT:					queueToMerge.reverseQueue();					for(i = 0; i < iLimit; i++)					{						insertInQueue(queueToMerge.nextInQueue(), 0);					}					break;									case DISTRIBUTE_RANDOM:					for(i = 0; i < iLimit; i++)					{						var position:int = MathUtils.randomWithinRange(earliestPosition, _items.length);						_items.splice(position, 0, queueToMerge.nextInQueue());					}					break;				case DISTRIBUTE_EVEN:					var iterate:int = int(_items.length / iLimit);					if(iterate <= 0) iterate = 2;										var counter:int = -1;					if(earliestPosition >= 0) counter = earliestPosition - 2;										for(i = 0; i < iLimit; i++)					{						counter += iterate;						_items.splice(counter, 0, queueToMerge.nextInQueue());						//trace(counter)					}					break;									//DISTRIBUTE_END is default				default:					for(i = 0; i < iLimit; i++)					{						insertInQueue(queueToMerge.nextInQueue());					}					break;								}		}				public function shuffle():void		{			var iLimit:int = _items.length;			var temp:*;			var rand:int;			for (var i:int = 0; i < iLimit; i++)			{				temp = _items[i];				rand = int( Math.random() * iLimit);								_items[i] = _items[rand];				_items[rand] = temp;			}		}				public function toString():String		{			return _items.toString();		}				public function displayPropertyOfQueueItems(propertyName:String):String		{			var returnVal:Array = [];			for(var i:int = 0; i < _items.length; i++) returnVal.push(_items[i][propertyName]);			return returnVal.toString();		}			}	}